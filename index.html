<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- bootstrap styling -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">


  <!-- google icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <title>PPM Visualization</title>

  <style>
    html,
    body {
      background-color: #3b414d;
      font-family: Arial;
      width: 100%;
      margin: 0;
      padding: 0;
    }

    h1 {
      font-size: 38px;
      color: #fff;
      margin: 25px 0 25px 0;
    }

    p {
      color: #FFFFFF;
      max-width: 500px;
      margin: 0 auto;
      padding: 5px 15px 5px 15px;
    }

    canvas {
      background-color: #FFFFFF;
      border: 1px solid grey;
      margin: 0 auto 2.5vw auto;
    }

    #container {
      margin: 0 auto;
      text-align: center;
      overflow: auto;
    }

    #range-value {
      color: #FFFFFF
    }

    #input-container {
      width: 90vw;
      max-width: 400px;
      background-color: #ffffff;
      padding: 20px;
      margin: 0 auto 20px auto;
      border-radius: 5px;
      text-align: left;
    }

    .info-icon:hover {
      color: #007bff;
      cursor: pointer;
    }

    @media only screen and (max-width: 500px) {
      h1 {
        font-size: 34px;
      }
    }
  </style>
</head>

<body onresize="windowResize()">
  <div id="container">
    <h1>Part Per Million Visualization</h1>

    <div id="input-container">
      <div class="form-group">
        <label class="col-form-label col-form-label-sm" for="number-of-particles">Select PPM (1 - 10000)</label>
        <input class="form-control form-control-sm" type="number" id="number-of-particles" name="number-of-dots" min="1" max="10000" value="400" autofocus>
      </div>

      <hr>

      <div class="form-group">
        <label class="col-form-label col-form-label-sm" for="ppm-color">Select Color</label>
        <input class="form-control form-control-sm" type="color" id="ppm-color" name="ppm-color" value="#a10067">
      </div>

      <hr>

      <div class="form-group">
        <div class="form-check form-check-inline">
          <input class="form-check-input" type="radio" id="gas" name="statetype" value="300" checked>
          <label for="gas" class="form-check-label">gas</label>
        </div>

        <div class="form-check form-check-inline">
          <input class="form-check-input" type="radio" id="liquid-solid" name="statetype" value="100">
          <label for="liquid-solid" class="form-check-label">liquid &#x2f; solid</label>
        </div>
      </div>

      <hr>

      <div>
        <div class="form-check form-check-inline">
          <input class="form-check-input" type="checkbox" id="bounding-box" name="bounding-box" checked>
          <label for="bounding-box" class="form-check-label">bounding box</label>
        </div>
      </div>

      <hr>

      <div>
        <button type="button" class="btn btn-primary btn-sm" id="runPPM">Calculate PPM</button>
      </div>


    </div>

    <canvas id="canvas"></canvas>


  </div>

  <script>
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let maxCanvasWidth = 860;
    let setCanvasWidthHeight = function () {return window.innerWidth > maxCanvasWidth ? maxCanvasWidth * .9 : window.innerWidth * .9};
    ctx.canvas.width = setCanvasWidthHeight();
    ctx.canvas.height = setCanvasWidthHeight(); // set height same as width for simplicity
    let width = canvas.width;
    let height = canvas.height;
    let depth = canvas.width;
    let xCenter = width / 2; // X center position for rotation calculation
    let zCenter = depth / 2; // Z center position for rotation calculation
    let blockPercentage = .5; // control particle block size with this number (width * this.number = block width)
    let blockWidth = width * blockPercentage; // set volume(block) width as a percentage of canvas width
    let blockHeight = height * blockPercentage; // set volume(block) height as a percentage of canvas height
    let blockDepth = depth * blockPercentage; //
    let particles; // var to hold all particles
    let boundingBox; // var to hold bounding box
    let frame; // contains the animation frame so it can be canceled later
    let rotationSpeed = 0.01; // value is in radians
    let boxPadding = 6;
    let numberOfParticles = Number(document.getElementById('number-of-particles').value); // get initial number of dots
    let particleColor = document.getElementById('ppm-color').value; // get initial particle color
    let stateType = document.querySelector('input[name="statetype"]:checked').value; // get initial radio button selection for gas or solid/liquid
    let maxRange = Number(document.getElementById('number-of-particles').max); // get max number of particles
    let boundingBoxSelected = document.getElementById('bounding-box').checked; // get if bounding box is selected


    // class to make a bounding box
    class BoundingBox {
      constructor() {
        this.points = [
          {
            pointNumber: 1,
            x: (width / 2) - (blockWidth / 2) - boxPadding,
            y: (height / 2) - (blockHeight / 2) - boxPadding,
            z: (depth / 2) - (blockDepth / 2) - boxPadding,
            yAdjusted: (height / 2) - (blockHeight / 2) - boxPadding,
            xAdjusted: (width / 2) - (blockWidth / 2) - boxPadding,
          },
          {
            pointNumber: 2,
            x: (width / 2) + (blockWidth / 2) + boxPadding,
            y: (height / 2) - (blockHeight / 2) - boxPadding,
            z: (depth / 2) - (blockDepth / 2) - boxPadding,
            yAdjusted: (height / 2) - (blockHeight / 2) - boxPadding,
            xAdjusted: (width / 2) + (blockWidth / 2) + boxPadding,
          },
          {
            pointNumber: 3,
            x: (width / 2) + (blockWidth / 2) + boxPadding,
            y: (height / 2) - (blockHeight / 2) - boxPadding,
            z: (depth / 2) + (blockDepth / 2) + boxPadding,
            yAdjusted: (height / 2) - (blockHeight / 2) - boxPadding,
            xAdjusted: (width / 2) + (blockWidth / 2) + boxPadding,
          },
          {
            pointNumber: 4,
            x: (width / 2) - (blockWidth / 2) - boxPadding,
            y: (height / 2) - (blockHeight / 2) - boxPadding,
            z: (depth / 2) + (blockDepth / 2) + boxPadding,
            yAdjusted: (height / 2) - (blockHeight / 2) - boxPadding,
            xAdjusted: (width / 2) - (blockWidth / 2) - boxPadding,
          },
          {
            pointNumber: 5,
            x: (width / 2) - (blockWidth / 2) - boxPadding,
            y: (height / 2) + (blockHeight / 2) + boxPadding,
            z: (depth / 2) - (blockDepth / 2) - boxPadding,
            yAdjusted: (height / 2) + (blockHeight / 2) + boxPadding,
            xAdjusted: (width / 2) - (blockWidth / 2) - boxPadding,
          },
          {
            pointNumber: 6,
            x: (width / 2) + (blockWidth / 2) + boxPadding,
            y: (height / 2) + (blockHeight / 2) + boxPadding,
            z: (depth / 2) - (blockDepth / 2) - boxPadding,
            yAdjusted: (height / 2) + (blockHeight / 2) + boxPadding,
            xAdjusted: (width / 2) + (blockWidth / 2) + boxPadding,
          },
          {
            pointNumber: 7,
            x: (width / 2) + (blockWidth / 2) + boxPadding,
            y: (height / 2) + (blockHeight / 2) + boxPadding,
            z: (depth / 2) + (blockDepth / 2) + boxPadding,
            yAdjusted: (height / 2) + (blockHeight / 2) + boxPadding,
            xAdjusted: (width / 2) + (blockWidth / 2) + boxPadding,
          },
          {
            pointNumber: 8,
            x: (width / 2) - (blockWidth / 2) - boxPadding,
            y: (height / 2) + (blockHeight / 2) + boxPadding,
            z: (depth / 2) + (blockDepth / 2) + boxPadding,
            yAdjusted: (height / 2) + (blockHeight / 2) + boxPadding,
            xAdjusted: (width / 2) - (blockWidth / 2) - boxPadding,
          },
        ];
      }
      rotate() {
        let tempObj = this.points.map(v => {
            var newX = (((v.x - xCenter) * Math.cos(rotationSpeed)) - ((v.z - zCenter) * Math.sin(rotationSpeed))) + xCenter
            var newZ = (((v.z - zCenter) * Math.cos(rotationSpeed)) + ((v.x - xCenter) * Math.sin(rotationSpeed))) + zCenter

            return ({
              pointNumber: v.pointNumber,
              x: newX,
              y: v.y,
              z: newZ,
              yAdjusted: perspective(v.y, newZ, 'y'),
              xAdjusted: perspective(newX, newZ, 'x')
            })
          }
        ).sort((a, b) => a.pointNumber - b.pointNumber)

        this.points = tempObj;
      }
      draw() {
        // draw bounding box points
        for (let i = 0; i < this.points.length; i++) {
          ctx.globalAlpha = Math.abs(1 - ((this.points[i].z / width) / 1.3));
          ctx.beginPath();
          ctx.arc(this.points[i].xAdjusted, this.points[i].yAdjusted, 3, 0, 360);
          ctx.fillStyle = '#cbcbcb';
          ctx.fill();
          ctx.closePath();
        }
        // draw bounding box lines
        ctx.beginPath();
        ctx.moveTo(this.points[0].xAdjusted, this.points[0].yAdjusted);
        ctx.lineTo(this.points[1].xAdjusted, this.points[1].yAdjusted);
        ctx.lineTo(this.points[2].xAdjusted, this.points[2].yAdjusted);
        ctx.lineTo(this.points[3].xAdjusted, this.points[3].yAdjusted);
        ctx.lineTo(this.points[0].xAdjusted, this.points[0].yAdjusted);
        ctx.lineTo(this.points[4].xAdjusted, this.points[4].yAdjusted);
        ctx.lineTo(this.points[5].xAdjusted, this.points[5].yAdjusted);
        ctx.lineTo(this.points[6].xAdjusted, this.points[6].yAdjusted);
        ctx.lineTo(this.points[7].xAdjusted, this.points[7].yAdjusted);
        ctx.lineTo(this.points[4].xAdjusted, this.points[4].yAdjusted);
        ctx.moveTo(this.points[1].xAdjusted, this.points[1].yAdjusted);
        ctx.lineTo(this.points[5].xAdjusted, this.points[5].yAdjusted);
        ctx.moveTo(this.points[2].xAdjusted, this.points[2].yAdjusted);
        ctx.lineTo(this.points[6].xAdjusted, this.points[6].yAdjusted);
        ctx.moveTo(this.points[3].xAdjusted, this.points[3].yAdjusted);
        ctx.lineTo(this.points[7].xAdjusted, this.points[7].yAdjusted);
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#cbcbcb';
        ctx.stroke();
      }
    }



    // class to make particles
    class Particle {
      constructor() {
        this.x = (Math.random() * blockWidth) + ((width - blockWidth) / 2);
        this.y = (Math.random() * blockHeight) + ((height - blockHeight) / 2);
        this.z = (Math.random() * blockDepth) + ((depth - blockDepth) / 2);
        // set initial xAdjusted and yAdjusted to same as x and y positions
        this.xAdjusted = (Math.random() * blockWidth) + ((width - blockWidth) / 2); // to hold x position based on depth perspective
        this.yAdjusted = (Math.random() * blockHeight) + ((height - blockHeight) / 2); // to hold y position based on depth perspective
      }
      rotate() {
        let tempX = (((this.x - xCenter) * Math.cos(rotationSpeed)) - ((this.z - zCenter) * Math.sin(rotationSpeed))) + xCenter;
        let tempZ = (((this.z - zCenter) * Math.cos(rotationSpeed)) + ((this.x - xCenter) * Math.sin(rotationSpeed))) + zCenter;
        this.x = tempX;
        this.z = tempZ;
        this.xAdjusted = perspective(tempX, tempZ, 'x');
        this.yAdjusted = perspective(this.y, tempZ, 'y');
      }
      draw() {
        let particleWidth = blockWidth / stateType; // 100 = solid-liquid, 300 = gas
        ctx.globalAlpha = Math.abs(1 - ((this.z / width) / 1.3));
        ctx.beginPath();
        ctx.arc(this.xAdjusted, this.yAdjusted, particleWidth, 0, 360);
        ctx.fillStyle = particleColor;
        ctx.fill();
        ctx.closePath();
      }
    }



    // function to calculate yPerspective and xPerspective for the perception of depth
    function perspective(position, zDepth, axis) {
      if (axis == 'y') {
        let perspectiveRatio = ((zCenter - position) / (blockHeight / 2)); // gives a number between -1 and 1 to represent how far from Y center particle is
        let zRatio = (zDepth - (width / 2)) / (blockWidth / 2); // gives a number from -1 to 1 to represent particle depth
        let yMultiplier = 20;
        let adjustment = perspectiveRatio * zRatio * yMultiplier;
        return position + adjustment;
      } else if (axis == 'x') {
        let xRatio = (position - xCenter) / xCenter; // express x position as number from -1 to 1
        let zRatio = (zDepth - zCenter) / zCenter;// express z position as number from -1 to 1
        let direction = xRatio * zRatio > 0 ? -1 : 1; // set direction to adjust based on quadrant
        let xMultiplier = 80; // used to amplify movement
        let adjustment = (Math.abs(xRatio) * Math.abs(zRatio)) * direction * xMultiplier; // calculate adjustment
        return position + adjustment;
      }
    }



    function makeParticles() {
      if (numberOfParticles <= maxRange && numberOfParticles >= 1) { // if numberOfDots is in range
        particles = []; // erase existing particles

        for (let i = 0; i < numberOfParticles; i++) {
          particles.push(new Particle())
        }
      }
    }



    function makeBoundingBox() {
      boundingBox = new BoundingBox();
    }



    // on window resize reset canvas width and height and recalculate all relevant sizes
    function windowResize() {
      ctx.canvas.width = setCanvasWidthHeight();
      ctx.canvas.height = setCanvasWidthHeight();
      width = canvas.width;
      height = canvas.height;
      depth = canvas.width;
      xCenter = width / 2;
      zCenter = depth / 2;
      blockWidth = width * blockPercentage;
      blockHeight = height * blockPercentage;
      blockDepth = depth * blockPercentage;
      window.cancelAnimationFrame(frame);
      makeParticles();
      makeBoundingBox();
      frame = window.requestAnimationFrame(drawPPM);
    }



    // main function to draw the particles
    function drawPPM() {
      ctx.clearRect(0, 0, width, height);

      if (boundingBoxSelected) {
        boundingBox.rotate();
        boundingBox.draw();
      }

      for (let j = 0; j < particles.length; j++) {
        particles[j].rotate();
        particles[j].draw();
      }

      frame = window.requestAnimationFrame(drawPPM)
    }



    // when 'Calculate PPM' button is clicked run calculatePPM function
    document.getElementById("runPPM").onclick = function() {
      window.cancelAnimationFrame(frame); // cancel current animation frame

      // reset particle based on current inputs
      numberOfParticles = document.getElementById('number-of-particles').value; // get current number of dots
      particleColor = document.getElementById('ppm-color').value; // get current color
      stateType = document.querySelector('input[name="statetype"]:checked').value; // get if gas or solid/liquid
      makeParticles(); // make a new set of dots based on new user settings

      // reset visibility of bounding box based on current inputs
      boundingBoxSelected = document.getElementById('bounding-box').checked;
      makeBoundingBox();

      frame = window.requestAnimationFrame(drawPPM); // request new animation frame and run it
    }


    // run initial program
    makeParticles();
    makeBoundingBox();
    frame = window.requestAnimationFrame(drawPPM);


  </script>
</body>

</html>
